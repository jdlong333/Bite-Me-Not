<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bite Me Not - Fasting Tracker</title>
    <meta name="description" content="A simple fasting tracker app.">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Bite Me Not">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3b82f6">
    <link rel="icon" href="https://placehold.co/32x32/3b82f6/FFFFFF?text=F" sizes="32x32" type="image/png">
    <link rel="icon" href="https://placehold.co/192x192/3b82f6/FFFFFF?text=F" sizes="192x192" type="image/png">
    <link rel="apple-touch-icon" href="https://placehold.co/180x180/2563eb/FFFFFF?text=BMN">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/wheelpicker/dist/wheelpicker.min.css">
    <script src="https://cdn.jsdelivr.net/npm/wheelpicker/dist/wheelpicker.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f9fafb;
            color: #1f2937;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        #app {
            width: 100%;
            max-width: 448px;
            padding: 1rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #progress-container {
            position: relative;
            width: 70%;
            max-width: 280px;
            aspect-ratio: 1;
            margin: 2rem auto;
        }
        #progress-svg {
            width: 100%;
            height: 100%;
        }
        #progress-circle-bg {
            fill: none;
            stroke: #e5e7eb;
            stroke-width: 12;
        }
        #progress-circle {
            fill: none;
            stroke: #3b82f6;
            stroke-width: 12;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: 50% 50%;
            transition: stroke-dashoffset 0.35s ease-out, stroke 0.35s ease-out;
        }
        .goal-reached-svg #progress-circle {
            stroke: #22c55e;
        }
        #time-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: 600;
            color: #1f2937;
            transition: color 0.35s ease-out;
        }
        .goal-reached-timedisplay {
            color: #22c55e;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        button {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover:not(:disabled) {
            background-color: #2563eb;
        }
        button:disabled {
            background-color: #d1d5db;
            cursor: not-allowed;
        }
        #goal-selector {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        .goal-btn {
            background-color: #e5e7eb;
            color: #4b5563;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .goal-btn:hover:not(.selected) {
            background-color: #d1d5db;
        }
        .goal-btn.selected {
            background-color: #3b82f6;
            color: white;
        }
        #status-message {
            text-align: center;
            font-size: 0.875rem;
            color: #4b5563;
            margin-top: 1rem;
            min-height: 1lh;
        }
        #stage-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: inset 0 0 20px rgba(59, 130, 246, 0.2);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.35s ease-out;
        }
        #stage-indicator.is-visible {
            opacity: 1;
        }
        #predicted-end-time {
            text-align: center;
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 0.5rem;
            opacity: 0;
            transition: opacity 0.35s ease-out;
        }
        #predicted-end-time.is-visible {
            opacity: 1;
        }
        #streak-display {
            text-align: center;
            font-size: 1rem;
            font-weight: 500;
            margin-top: 1rem;
            transition: color 0.35s ease-out;
        }
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1f2937;
                color: #f9fafb;
            }
            #progress-circle-bg {
                stroke: #374151;
            }
            #time-display {
                color: #f9fafb;
            }
            #status-message {
                color: #d1d5db;
            }
            #predicted-end-time {
                color: #9ca3af;
            }
            .goal-btn {
                background-color: #374151;
                color: #d1d5db;
            }
            .goal-btn:hover:not(.selected) {
                background-color: #4b5563;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div>
            <div id="progress-container">
                <svg id="progress-svg" viewBox="0 0 100 100">
                    <circle id="progress-circle-bg" cx="50" cy="50" r="42"/>
                    <circle id="progress-circle" cx="50" cy="50" r="42" stroke-dasharray="263.89" stroke-dashoffset="263.89"/>
                </svg>
                <div id="stage-indicator"></div>
                <div id="time-display"><span id="time-display-text">00:00:00</span></div>
            </div>
            <div id="predicted-end-time"></div>
            <div id="streak-display">Streak: 0 days</div>
            <div id="status-message"></div>
        </div>
        <div id="controls">
            <div id="goal-selector">
                <button class="goal-btn" data-hours="16">16h</button>
                <button class="goal-btn" data-hours="18">18h</button>
                <button class="goal-btn" data-hours="20">20h</button>
                <button class="goal-btn" data-hours="24">24h</button>
            </div>
            <button id="start-btn">Start Fast</button>
            <button id="stop-btn" disabled>End Fast</button>
        </div>
    </div>
    <script>
        const CIRCLE_RADIUS = 42;
        const CIRCUMFERENCE = 2 * Math.PI * CIRCLE_RADIUS;
        const progressSvg = document.getElementById('progress-svg');
        const progressCircle = document.getElementById('progress-circle');
        const timeDisplay = document.getElementById('time-display');
        const timeDisplayText = document.getElementById('time-display-text');
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const goalButtons = document.querySelectorAll('.goal-btn');
        const statusMessage = document.getElementById('status-message');
        const stageIndicator = document.getElementById('stage-indicator');
        const predictedEndTimeDisplay = document.getElementById('predicted-end-time');
        const streakDisplay = document.getElementById('streak-display');

        let animationFrameId = null;
        let lastTextUpdateTimestamp = 0;

        const appState = loadState();

        function loadState() {
            try {
                const savedState = localStorage.getItem('fastingAppState');
                const defaultState = {
                    isFasting: false,
                    fastStartTime: null,
                    selectedFastHours: 18,
                    history: []
                };
                if (!savedState) return defaultState;
                const parsedState = JSON.parse(savedState);
                if (parsedState.fastStartTime) {
                    parsedState.fastStartTime = new Date(parsedState.fastStartTime);
                }
                return { ...defaultState, ...parsedState };
            } catch (e) {
                console.error("Error loading state:", e);
                return {
                    isFasting: false,
                    fastStartTime: null,
                    selectedFastHours: 18,
                    history: []
                };
            }
        }

        function saveState() {
            try {
                const stateToSave = { ...appState };
                localStorage.setItem('fastingAppState', JSON.stringify(stateToSave));
            } catch (e) {
                console.error("Error saving state:", e);
            }
        }

        function setProgress(percentage) {
            const offset = CIRCUMFERENCE - (percentage / 100) * CIRCUMFERENCE;
            progressCircle.style.strokeDashoffset = offset;
        }

        function formatDuration(ms) {
            try {
                const seconds = Math.floor(ms / 1000);
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            } catch (e) {
                console.error("Error formatting duration:", e);
                return "00:00:00";
            }
        }

        function formatPredictedEndTime(date) {
            try {
                return `Predicted end: ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
            } catch (e) {
                console.error("Error formatting predicted end time:", e);
                return "Unknown";
            }
        }

        function getHistory() {
            try {
                return appState.history || [];
            } catch (e) {
                console.error("Error retrieving history:", e);
                return [];
            }
        }

        function addFastToHistory(startTime, endTime, goalHours) {
            try {
                appState.history = appState.history || [];
                appState.history.push({
                    startTime: startTime.toISOString(),
                    endTime: endTime.toISOString(),
                    goalHours: goalHours
                });
                saveState();
                return true;
            } catch (e) {
                console.error("Error adding fast to history:", e);
                return false;
            }
        }

        function calculateCurrentStreak() {
            try {
                const history = getHistory();
                if (history.length === 0) return 0;

                const fastingDays = new Set();
                history.forEach(fast => {
                    const endDate = new Date(fast.endTime);
                    const dayString = endDate.toLocaleDateString();
                    fastingDays.add(dayString);
                });

                let streak = 0;
                let currentDate = new Date();
                currentDate.setHours(0, 0, 0, 0);

                while (true) {
                    const dayString = currentDate.toLocaleDateString();
                    if (fastingDays.has(dayString)) {
                        streak++;
                        currentDate.setDate(currentDate.getDate() - 1);
                    } else {
                        break;
                    }
                }

                if (streak === 0 && fastingDays.size > 0) {
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    yesterday.setHours(0, 0, 0, 0);
                    if (fastingDays.has(yesterday.toLocaleDateString())) {
                        streak = 1;
                        currentDate = new Date(yesterday);
                        currentDate.setDate(currentDate.getDate() - 1);
                        while (fastingDays.has(currentDate.toLocaleDateString())) {
                            streak++;
                            currentDate.setDate(currentDate.getDate() - 1);
                        }
                    }
                }

                console.log(`Calculated streak: ${streak}`);
                return streak;
            } catch (e) {
                console.error("Error calculating streak:", e);
                return 0;
            }
        }

        function updateStreakDisplay() {
            const streak = calculateCurrentStreak();
            streakDisplay.textContent = `Streak: ${streak} day${streak === 1 ? '' : 's'}`;
            if (streak >= 7) {
                streakDisplay.style.color = '#22c55e';
            } else if (streak >= 3) {
                streakDisplay.style.color = '#3b82f6';
            } else {
                streakDisplay.style.color = '';
            }
        }

        function animationLoop(timestamp) {
            try {
                const now = new Date();
                const elapsedMs = now - appState.fastStartTime;
                const goalMs = appState.selectedFastHours * 60 * 60 * 1000;
                const percentage = Math.min((elapsedMs / goalMs) * 100, 100);
                setProgress(percentage);

                if (elapsedMs >= goalMs) {
                    progressSvg.classList.add('goal-reached-svg');
                    timeDisplay.classList.add('goal-reached-timedisplay');
                }

                if (timestamp - lastTextUpdateTimestamp >= 1000) {
                    timeDisplayText.textContent = formatDuration(elapsedMs);
                    lastTextUpdateTimestamp = timestamp;
                }

                animationFrameId = requestAnimationFrame(animationLoop);
            } catch (e) {
                console.error("Error in animation loop:", e);
            }
        }

        function startFast() {
            const picker = new WheelPicker({
                data: [
                    { id: 'hour', items: Array.from({ length: 24 }, (_, i) => ({ value: i, label: String(i).padStart(2, '0') })) },
                    { id: 'minute', items: Array.from({ length: 60 }, (_, i) => ({ value: i, label: String(i).padStart(2, '0') })) }
                ],
                onChange: (selected) => {
                    const now = new Date();
                    const selectedHour = selected.hour;
                    const selectedMinute = selected.minute;
                    now.setHours(selectedHour, selectedMinute, 0, 0);
                    appState.fastStartTime = now;
                    picker.destroy();
                    proceedStartFast();
                }
            });
            picker.show();
        }

        function proceedStartFast() {
            appState.isFasting = true;
            lastTextUpdateTimestamp = 0;
            saveState();
            updateUI();
            stageIndicator.classList.add('is-visible');

            try {
                const goalMs = appState.selectedFastHours * 60 * 60 * 1000;
                if (goalMs > 0) {
                    const predictedEnd = new Date(appState.fastStartTime.getTime() + goalMs);
                    const formattedEndTime = formatPredictedEndTime(predictedEnd);
                    predictedEndTimeDisplay.textContent = formattedEndTime;
                    predictedEndTimeDisplay.classList.add('is-visible');
                } else {
                    predictedEndTimeDisplay.textContent = '';
                    predictedEndTimeDisplay.classList.remove('is-visible');
                }
            } catch (e) {
                console.error("Error formatting/displaying predicted end time:", e);
                predictedEndTimeDisplay.textContent = 'Error calculating end time';
                predictedEndTimeDisplay.classList.add('is-visible');
            }

            progressSvg.classList.remove('goal-reached-svg');
            timeDisplay.classList.remove('goal-reached-timedisplay');
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(animationLoop);
            console.log(`Fast started: ${appState.fastStartTime}, Goal: ${appState.selectedFastHours}h`);
        }

        function stopFast() {
            const picker = new WheelPicker({
                data: [
                    { id: 'hour', items: Array.from({ length: 24 }, (_, i) => ({ value: i, label: String(i).padStart(2, '0') })) },
                    { id: 'minute', items: Array.from({ length: 60 }, (_, i) => ({ value: i, label: String(i).padStart(2, '0') })) }
                ],
                onChange: (selected) => {
                    const now = new Date();
                    const selectedHour = selected.hour;
                    const selectedMinute = selected.minute;
                    now.setHours(selectedHour, selectedMinute, 0, 0);
                    const fastEndTimeActual = now;
                    picker.destroy();
                    proceedStopFast(fastEndTimeActual);
                }
            });
            picker.show();
        }

        function proceedStopFast(fastEndTimeActual) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            const success = addFastToHistory(appState.fastStartTime, fastEndTimeActual, appState.selectedFastHours);
            if (success) {
                const durationMs = fastEndTimeActual - appState.fastStartTime;
                appState.isFasting = false;
                appState.fastStartTime = null;
                saveState();
                updateUI(`Fast completed! Duration: ${formatDuration(durationMs)}`, 3000);
                updateStreakDisplay();
            } else {
                updateUI("Error saving completed fast.", 3000);
            }
            setProgress(0);
            timeDisplayText.textContent = '00:00:00';
        }

        function updateUI(message = '', timeout = 0) {
            startBtn.disabled = appState.isFasting;
            stopBtn.disabled = !appState.isFasting;
            statusMessage.textContent = message;
            if (timeout > 0) {
                setTimeout(() => {
                    if (statusMessage.textContent === message) {
                        statusMessage.textContent = '';
                    }
                }, timeout);
            }
            if (!appState.isFasting) {
                stageIndicator.classList.remove('is-visible');
                predictedEndTimeDisplay.classList.remove('is-visible');
                setProgress(0);
                timeDisplayText.textContent = '00:00:00';
            }
            updateStreakDisplay();
        }

        startBtn.addEventListener('click', startFast);
        stopBtn.addEventListener('click', stopFast);

        goalButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                if (appState.isFasting) return;
                goalButtons.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                appState.selectedFastHours = parseInt(btn.dataset.hours);
                saveState();
                updateUI(`Fasting goal set to ${appState.selectedFastHours} hours`);
            });
            if (parseInt(btn.dataset.hours) === appState.selectedFastHours) {
                btn.classList.add('selected');
            }
        });

        updateUI();
        if (appState.isFasting) {
            animationFrameId = requestAnimationFrame(animationLoop);
            stageIndicator.classList.add('is-visible');
            const goalMs = appState.selectedFastHours * 60 * 60 * 1000;
            const predictedEnd = new Date(appState.fastStartTime.getTime() + goalMs);
            predictedEndTimeDisplay.textContent = formatPredictedEndTime(predictedEnd);
            predictedEndTimeDisplay.classList.add('is-visible');
        }
    </script>
</body>
</html>
